package frc.quixlib.maplesim;

import static edu.wpi.first.units.Units.*;

import edu.wpi.first.math.geometry.Pose2d;
import edu.wpi.first.math.geometry.Rotation2d;
import edu.wpi.first.math.geometry.Transform2d;
import edu.wpi.first.math.geometry.Translation2d;
import edu.wpi.first.math.kinematics.ChassisSpeeds;
import edu.wpi.first.units.measure.LinearAcceleration;
import frc.quixlib.swerve.QuixSwerveModule;
import org.dyn4j.geometry.Vector2;
import org.ironmaple.simulation.drivesims.AbstractDriveTrainSimulation;
import org.ironmaple.simulation.drivesims.GyroSimulation;
import org.ironmaple.simulation.drivesims.configs.DriveTrainSimulationConfig;

/**
 * QuixSwerveDriveSimulation simulates the behavior of a swerve drive train. It extends the
 * AbstractDriveTrainSimulation class and provides functionality to simulate the dynamics of a
 * swerve drive system, including the effects of friction and module forces.
 *
 * <p>This class is responsible for updating the simulation state of each swerve module, computing
 * the forces generated by each module, and applying these forces to the simulated robot. It also
 * updates the gyro simulation to reflect the current state of the robot.
 *
 * <p>Constructor parameters:
 *
 * @param config The configuration for the drive train simulation.
 * @param modules An array of QuixSwerveModule representing the swerve modules.
 * @param cof The coefficient of friction for the drive train.
 * @param initialPoseOnField The initial pose of the robot on the field.
 *     <p>Methods:
 *     <ul>
 *       <li>{@link #simulationSubTick()}: Updates the simulation state for each simulation tick,
 *           including module velocities, forces, and gyro state.
 *       <li>{@link #getGyroSimulation()}: Returns the gyro simulation instance.
 *     </ul>
 */
public class QuixSwerveDriveSimulation extends AbstractDriveTrainSimulation {
  private static final LinearAcceleration kG = MetersPerSecondPerSecond.of(9.81);

  private final QuixSwerveModule[] m_modules;
  private final GyroSimulation m_gyroSimulation;
  private final double m_maxFrictionForcePerModule;

  public QuixSwerveDriveSimulation(
      DriveTrainSimulationConfig config,
      QuixSwerveModule[] modules,
      double cof,
      Pose2d initialPoseOnField) {
    super(config, initialPoseOnField);
    m_modules = modules;
    m_gyroSimulation = config.gyroSimulationFactory.get();
    m_maxFrictionForcePerModule =
        config.robotMass.div(m_modules.length).times(kG).times(cof).in(Newton);
  }

  @Override
  public void simulationSubTick() {
    final Pose2d simPose = getSimulatedDriveTrainPose();

    // Determine the ground speed at each module
    final ChassisSpeeds chassisSpeeds = getDriveTrainSimulatedChassisSpeedsRobotRelative();
    final Transform2d simRobotVelocity =
        new Transform2d(
            chassisSpeeds.vxMetersPerSecond,
            chassisSpeeds.vyMetersPerSecond,
            new Rotation2d(chassisSpeeds.omegaRadiansPerSecond));

    for (var module : m_modules) {
      // Update each module sim with the component of the robot velocity vector aligned with the
      // module.
      final Translation2d modulePosition = module.getPosition();
      final double moduleDist = modulePosition.getNorm();
      final double magnitude = moduleDist * simRobotVelocity.getRotation().getRadians();
      final Translation2d rotVectorComponentAtModule =
          modulePosition.div(moduleDist).rotateBy(Rotation2d.kCCW_Pi_2).times(magnitude);
      final Translation2d totalVectorAtModule =
          simRobotVelocity.getTranslation().plus(rotVectorComponentAtModule);
      final double moduleAngle = module.getSteeringAngle();
      final double moduleAlignedVelocity =
          totalVectorAtModule.getNorm() < 1e-3
              ? 0.0
              : totalVectorAtModule.getNorm()
                  * Math.cos(moduleAngle - totalVectorAtModule.getAngle().getRadians());
      module.updateSimSubtick(moduleAlignedVelocity);

      // Compute drive forces from each module.
      Translation2d moduleForce = module.getGroundForceVector(m_maxFrictionForcePerModule);

      // Comptue lateral friction forces at each module.
      final double moduleLateralVelocity =
          totalVectorAtModule.getNorm() < 1e-3
              ? 0.0
              : totalVectorAtModule.getNorm()
                  * Math.sin(moduleAngle - totalVectorAtModule.getAngle().getRadians());
      Translation2d frictionForceVector =
          new Translation2d(1, new Rotation2d(moduleAngle))
              .rotateBy(Rotation2d.kCCW_Pi_2)
              .times(
                  m_maxFrictionForcePerModule
                      * (Math.abs(moduleLateralVelocity) > 1e-2
                          ? Math.signum(moduleLateralVelocity)
                          : 0.0));

      // Ensure total force doesn't exceed max friction force.
      final Translation2d totalForce = moduleForce.plus(frictionForceVector);
      if (totalForce.getNorm() > m_maxFrictionForcePerModule) {
        final double scale = m_maxFrictionForcePerModule / totalForce.getNorm();
        moduleForce = moduleForce.times(scale);
        frictionForceVector = frictionForceVector.times(scale);
      }

      // Apply forces as world-coordinate vectors.
      final Translation2d modulePositionWorldCoordinates =
          modulePosition.rotateBy(simPose.getRotation()).plus(simPose.getTranslation());
      final Translation2d moduleForceWorldCoordinates = moduleForce.rotateBy(simPose.getRotation());
      final Translation2d frictionForceVectorWorldCoordinates =
          frictionForceVector.rotateBy(simPose.getRotation());

      // Apply module forces.
      super.applyForce(
          new Vector2(moduleForceWorldCoordinates.getX(), moduleForceWorldCoordinates.getY()),
          new Vector2(
              modulePositionWorldCoordinates.getX(), modulePositionWorldCoordinates.getY()));

      // Apply friction forces.
      super.applyForce(
          new Vector2(
              frictionForceVectorWorldCoordinates.getX(),
              frictionForceVectorWorldCoordinates.getY()),
          new Vector2(
              modulePositionWorldCoordinates.getX(), modulePositionWorldCoordinates.getY()));
    }

    m_gyroSimulation.updateSimulationSubTick(super.getAngularVelocity());
  }

  public GyroSimulation getGyroSimulation() {
    return m_gyroSimulation;
  }
}
